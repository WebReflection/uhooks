let e=null,t=new Set;const n=e=>{const{$:t,r:n,h:s}=e;u(n)&&(c.get(s).delete(e),n()),u(e.r=t())&&c.get(s).add(e)},s=()=>{const e=t;t=new Set,e.forEach((({h:e,c:t,a:n,e:s})=>{s&&e.apply(t,n)}))},c=new WeakMap,h=[],l=[];function o(e,t){return e!==this[t]}const r=e=>{const t=c.get(e);t&&d.then((()=>{t.forEach((e=>{e.r(),e.r=null,e.d=!0})),t.clear()}))},a=()=>e,i=e=>c.has(e),u=e=>"function"==typeof e,p=t=>{const s={h:c,c:null,a:null,e:0,i:0,s:[]};return c;function c(){const c=e;e=s,s.e=s.i=0;try{return t.apply(s.c=this,s.a=arguments)}finally{e=c,h.length&&d.then(h.forEach.bind(h.splice(0),n)),l.length&&l.splice(0).forEach(n)}}},d=Promise.resolve(),f=e=>({_:new Set,provide:$,value:e}),g=({_:e,value:t})=>(e.add(a()),t);function $(e){const{_:t,value:n}=this;n!==e&&(this._=new Set,this.value=e,t.forEach((({h:e,c:t,a:n})=>{e.apply(t,n)})))}const _=(e,t)=>v((()=>e),t),v=(e,t)=>{const n=a(),{i:s,s:c}=n;return s!==c.length&&t&&!t.some(o,c[s]._)||(c[s]={$:e(),_:t}),c[n.i++].$},w=e=>(t,n)=>{const s=a(),{i:h,s:l,h:r}=s,i=h===l.length;s.i++,i&&(c.has(r)||c.set(r,new Set),l[h]={$:t,_:n,r:null,d:!1,h:r}),(i||!n||l[h].d||n.some(o,l[h]._))&&e.push(l[h]),l[h].$=t,l[h]._=n,l[h].d=!1},y=w(h),E=w(l),S=(e,t)=>u(t)?t(e):t,m=(e,n,c)=>{const h=a(),{i:l,s:o}=h;l===o.length&&o.push({$:u(c)?c(n):S(void 0,n),set:n=>{o[l].$=e(o[l].$,n),(e=>{t.has(e)||(e.e=1,t.add(e),d.then(s))})(h)}});const{$:r,set:i}=o[h.i++];return[r,i]},b=e=>m(S,e),k=e=>{const t=a(),{i:n,s:s}=t;return n===s.length&&s.push({current:e}),s[t.i++]};export{f as createContext,r as dropEffect,i as hasEffect,p as hooked,_ as useCallback,g as useContext,y as useEffect,E as useLayoutEffect,v as useMemo,m as useReducer,k as useRef,b as useState,d as wait};
