self.uhooks=function(e){"use strict";let t=null,n=new Set;const s=e=>{const{$:t,r:n,h:s}=e;l(n)&&(o.get(s).delete(e),n()),l(e.r=t())&&o.get(s).add(e)},c=()=>{const e=n;n=new Set,e.forEach((({h:e,c:t,a:n,e:s})=>{s&&e.apply(t,n)}))},o=new WeakMap,u=[],r=[];function a(e,t){return e!==this[t]}const h=()=>t,l=e=>"function"==typeof e,i=Promise.resolve();function f(e){const{_:t,value:n}=this;n!==e&&(this._=new Set,this.value=e,t.forEach((({h:e,c:t,a:n})=>{e.apply(t,n)})))}const d=(e,t)=>{const n=h(),{i:s,s:c}=n;return s!==c.length&&t&&!t.some(a,c[s]._)||(c[s]={$:e(),_:t}),c[n.i++].$},p=e=>(t,n)=>{const s=h(),{i:c,s:u,h:r}=s,l=c===u.length;s.i++,l&&(o.has(r)||o.set(r,new Set),u[c]={$:t,_:n,r:null,d:!1,h:r}),(l||!n||u[c].d||n.some(a,u[c]._))&&e.push(u[c]),u[c].$=t,u[c]._=n,u[c].d=!1},g=p(u),E=p(r),$=(e,t)=>l(t)?t(e):t,_=(e,t,s)=>{const o=h(),{i:u,s:r}=o;u===r.length&&r.push({$:l(s)?s(t):$(void 0,t),set:t=>{r[u].$=e(r[u].$,t),(e=>{n.has(e)||(e.e=1,n.add(e),i.then(c))})(o)}});const{$:a,set:f}=r[o.i++];return[a,f]};return e.createContext=e=>({_:new Set,provide:f,value:e}),e.dropEffect=e=>{const t=o.get(e);t&&i.then((()=>{t.forEach((e=>{e.r(),e.r=null,e.d=!0})),t.clear()}))},e.hasEffect=e=>o.has(e),e.hooked=e=>{const n={h:c,c:null,a:null,e:0,i:0,s:[]};return c;function c(){const c=t;t=n,n.e=n.i=0;try{return e.apply(n.c=this,n.a=arguments)}finally{t=c,u.length&&i.then(u.forEach.bind(u.splice(0),s)),r.length&&r.splice(0).forEach(s)}}},e.useCallback=(e,t)=>d((()=>e),t),e.useContext=({_:e,value:t})=>(e.add(h()),t),e.useEffect=g,e.useLayoutEffect=E,e.useMemo=d,e.useReducer=_,e.useRef=e=>{const t=h(),{i:n,s:s}=t;return n===s.length&&s.push({current:e}),s[t.i++]},e.useState=e=>_($,e),e.wait=i,e}({});
