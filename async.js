self.uhooks=function(e){"use strict";var t=Promise;let n=null,s=new Set;const a=new WeakMap,c=e=>{const{$:t,r:n,h:s}=e;f(n)&&(r.get(s).delete(e),n()),f(e.r=t())&&r.get(s).add(e)},o=()=>{const e=s;s=new Set,e.forEach((({h:e,c:t,a:n,e:s})=>{s&&e.apply(t,n)}))},r=new WeakMap,u=[],h=[];function l(e,t){return e!==this[t]}const i=()=>a.get(n),f=e=>"function"==typeof e,p=e=>{const t={h:s,c:null,a:null,e:0,i:0,s:[]};return a.set(s,t),s;function s(){const a=n;n=s,t.e=t.i=0;try{return e.apply(t.c=this,t.a=arguments)}finally{n=a,u.length&&d.then(u.forEach.bind(u.splice(0),c)),h.length&&h.splice(0).forEach(c)}}},d=new t((e=>e()));function g(e){const{_:t,value:n}=this;n!==e&&(this._=new Set,this.value=e,t.forEach((({h:e,c:t,a:n})=>{e.apply(t,n)})))}const w=(e,t)=>{const n=i(),{i:s,s:a}=n;return s!==a.length&&t&&!t.some(l,a[s]._)||(a[s]={$:e(),_:t}),a[n.i++].$},_=e=>(t,n)=>{const s=i(),{i:a,s:c,h:o}=s,u=a===c.length;s.i++,u&&(r.has(o)||r.set(o,new Set),c[a]={$:t,_:n,r:null,h:o}),(u||!n||n.some(l,c[a]._))&&e.push(c[a]),c[a].$=t,c[a]._=n},y=_(u),v=_(h),E=(e,t)=>f(t)?t(e):t,$=(e,t,n)=>{const a=i(),{i:c,s:r}=a;c===r.length&&r.push({$:f(n)?n(t):E(void 0,t),set:t=>{r[c].$=e(r[c].$,t),(e=>{s.has(e)||(e.e=1,s.add(e),d.then(o))})(a)}});const{$:u,set:h}=r[a.i++];return[u,h]},k=new WeakMap;return e.createContext=e=>({_:new Set,provide:g,value:e}),e.dropEffect=e=>(e=>{const t=r.get(e);t&&d.then((()=>{t.forEach((e=>{e.r(),e.r=null})),t.clear()}))})(k.get(e)),e.hasEffect=e=>(e=>r.has(e))(k.get(e)),e.hooked=e=>{const t=p(e);return k.set(n,t),n;async function n(){return await t.apply(this,arguments)}},e.useCallback=(e,t)=>w((()=>e),t),e.useContext=({_:e,value:t})=>(e.add(i()),t),e.useEffect=y,e.useLayoutEffect=v,e.useMemo=w,e.useReducer=$,e.useRef=e=>{const t=i(),{i:n,s:s}=t;return n===s.length&&s.push({current:e}),s[t.i++]},e.useState=e=>$(E,e),e.wait=d,e}({});
